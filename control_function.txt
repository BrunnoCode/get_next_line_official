#README Brunno W Rocha
Github: BrunnoCode

#README GNL PARA INICIANTES E QUEM TEM DIFICULDADES DE CRIAR ALGORITMOS.

A Funcao GNL retorna apenas ate um \n (salto de linha).
Se a funcao é chamada em um loop, retornará todo conteúdo de um fd (File Descriptor, um file.txt por exemplo).

#Lembrando que a funcao read(int fd, char *buffer_lectura, )

Temos o seguinto problema abaixo, imagine que nosso buffer no processo de leitura seja: buffer[bon|/n|/n|dia] ? como salvaremos a ultima posicao?

buffer -> ho\nla
buffer -> com\n\nest\nas
buffer -> \n
buffer -> Hola\n + \0<- #Sempre adicionamos '\0' no final de toda String

CONSTRUINDO UM ALGORITMO DE UM GET_NEXT_LINE FUNCIONAL

1-Primeiro declaramos uma variavel static, esta que, por sua vez guardara sempre as ultimas letras lidas.
*Pode receber um tamanho definido static[BUFFER_SIZE + 1]
*Ou pode reinicializa-la com NULL.

*Tambem criamos um char *linha para a linha de retorno final.
    

2-Verificamos errores iniciais
    *Se BUFFER_SIZE iguala a 0, ou seja menor que 0, ou se a funcao read() nao encontra fd retornando um valor de -1, a funcao read() tem 3 valores de rotorno que sao: read(-1) nao leu = error, read(n(qualquer numero positivo)), read(0) terminou de ler tudo em fd, entao retornamos NULL em todos estes casos, nao ha nada para leitura.

3-Nossa static recebe um punteiro char * de uma funcao que retornara a quantidade de letras lidas de fd. O prototipo desta funcao pode ser: funcao(int fd, char *static)
        char    *funcao(fd, static)
                {
                    #Aqui criamos la logica
                    *Criamos um char *buffer de leitura
                    *Criamos um int num_control que ira controlar erros e  quantidade de bytes lidos.

                    *Nosso buffer de leitura recebe um malloc do tamanho que temos em nossa macro BUFFER_SIZE que esta definida no nosso get_next_line.h, BUFFER_SIZE pode ser qualquer quantidade numerica, numero que definira quantos bytes serao lidos. Ou seja malloc de BUFFER_SIZE + 1 (adicionamos +1 para o \0 no fim de cada string)

                    *Verificamos se o malloc retornou corretamente.
                        Se buffer nao tem memoria reservada, liberamos nossa statica com a funcao de free especial, algo assim: my_free(&static); em seguida retornamos NULL. Tudo se acaba por aqui.
                    
                }

4-Verificamos se nossa static contem algo lido
    *Se static nao tem nada, retornamos NULL.

5-Agora utilizamos nossa variavel char *linha de retorno
    *linha de retorno recebe um ponteiro char * do retorno de uma funcao que vai processar os datos lidos da nossa static
     -  linha = funcao(static)
        {

        }
    *Se linha nao leu nada
      -liberamos static e entao retornamos NULL.
        podemos usar um free() especial se quiser

6-Nossa static agora recebe um char * de uma funcao que vai atualizar o valor da static, esta atualizacao ocorre para apagar ate o primeiro \n encontrado e guardar apenas o que sobrou, lembrando que devemos sempre adicionar um \0 no final da string sobrante. O prototipo sera char *funcao(char *static)
   
     *Assim seria em codigo:
        static = funcao(static);

        Exemplo do que faz a funcao(static)

            char    *funcao(char *static)
            {
                #Aplicamos a logica aqui.
            }

7-Finalmente retornamos linha de retorno.
    return (line);
